# A pathogenesis of ignorance

There is a virus of ignorance in the programming discipline. Like all
viruses, it mutates and changes to keep the attacks successful. One of its most used weapons is labels: impede knowledge and critical thinking by promoting labels. Early witnesses called them "buzzwords". "Architecture", "pattern", "cloud"; and "security", for that matter. Later the virus started using acronyms as ammunition: "TDD", "MVC", "SAAS", "CRM"...

I have actually witnessed a manager find peace and confidence after
finding out about the "CRM" acronym. He immediately believed, without
actually getting into technical details, that he will be able to
easily provide a nontrivial system a client wanted. It's a solved
problem, he said, there are CRMs. He didn't even have any
concrete "CRM" in mind, he just marked the problem as solved and moved on. I couldn't think of a way to get him even to get to know the problem itself.

I tried to help people cope with the virus by refusing to use the
labels. I also tried explaining, for example, that "a cloud"
is really a cluster of servers sitting somewhere. But the result of me avoiding the buzzwords was just that that manager concluded that I was merely incompetent. As a matter or fact, he became quite condescending. Now he teaches me from time to time the latest buzzwords he learned.


# Did you really get MVC?

The view is the graphical interface the application presents to the user. It draws whatever the user should see, like menus or 3-dimensional world projection, and receives commands from the user, like button presses or mouse movements. It also receives updates from inside the application, like an info about another player's movement, or a new message to be displayed, and renders them accordingly. Based on that, the pseudocode is:

	V {
		par loop {
			receive a command from the user;
			pass the command to C
		}
		
		par loop {
			receive an update from C;
			apply the update to the rendering;
		}
	}

	C {
		par proc {
			change model with time
			send updates to V
		}
		
		par loop {
			receive command from V
			change M accordingly
			send changes to V
		}
		
		Querying for missing data by V from M is done through C, but
		should that be considered a command/update or a request/response?
	}
	
	M {
		data payload?
		set of objects (class/var/struct instances) representing the data
		library of classes/types/functions for working with the data
	}


Despite the kinda settled understanding, not everyone was satisfied with the result, so the fermentation continued and produced other "architectural" mosaics, like MVVM, for example. Even less people understand these new variations, and who can blame them when this kind of hairsplitting is not only incomprehensible, but outright counterproductive. This is what Wikipedia page says about MVVM:

 The view model of MVVM is a value converter; meaning the view model is responsible for exposing (converting) the data objects from the model in such a way that objects are easily managed and presented. In this respect, the view model is more model than view, and handles most if not all of the view's display logic.

So, you see, the "data objects" are "exposed" to be then easily "managed" and "presented". And the view model is more model that view, you see.

This kind of narrative actually reminds me somewhat theological writings. You kinda understand what they are talking about, but fail to grasp what they wanna say. A programmer couldn't write such a description. A programmer would probably write someting like: "we failed to split view from model, so we glued them back together". Byt methodists and prophets are not programmers. Instead of cleaning up and moving on, they wrote even more texts, which led to even more seminars, more bucks, more reputation.]



